// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol";

/**
 * @title LibSignatureVerify
 * @dev Library for EIP-712 signature verification of ALX Score attestations.
 *
 * This library provides secure signature verification for:
 * - ALX Score attestations (for tie-breaking in auctions)
 *
 * Uses OpenZeppelin's SignatureChecker for robust signature validation.
 *
 * @notice All signatures must be generated by the authorized ALX backend signer.
 * @notice Signatures are tied to specific contract addresses and chain IDs for security.
 */
library LibSignatureVerify {
    /// @dev Type hash for ALX Score attestation struct following EIP-712 standard.
    bytes32 private constant _ALX_SCORE_ATTEST_TYPEHASH =
        keccak256(
            "ALXScoreAttestation(address wallet,uint256 score,uint256 epochId,uint256 amount,uint256 nonce,uint256 deadline)"
        );

    /**
     * @notice Verify an ALX Score attestation signature.
     * @dev Validates that the ALX backend has attested to a wallet's score using EIP-712 signature.
     *
     * @param wallet The address of the wallet whose score is being verified.
     * @param score The ALX Score being attested to (must match signature).
     * @param epochId The epoch ID for the score.
     * @param amount The amount being attested to.
     * @param nonce The nonce for replay protection.
     * @param deadline The deadline for the signature validity.
     * @param signature The EIP-712 signature from the ALX backend signer.
     * @param trustedSigner The authorized ALX backend signer address.
     * @param verifyingContract The contract address that will verify this signature.
     *
     * @return True if the signature is valid and matches the provided parameters.
     *
     * @dev This function is used during auction settlement to verify score-based tie-breaking.
     * @dev The signature must be generated by the authorized ALX backend signer.
     * @dev The signature is tied to the specific contract address and chain ID.
     * @dev The signature includes nonce and deadline for replay protection.
     *
     * @custom:security This function includes nonce and deadline-based replay protection.
     * Signatures are tied to specific nonces and deadlines to prevent reuse across different contexts.
     */
    function verifyALXScore(
        address wallet,
        uint256 score,
        uint256 epochId,
        uint256 amount,
        uint256 nonce,
        uint256 deadline,
        bytes calldata signature,
        address trustedSigner,
        address verifyingContract
    ) internal view returns (bool) {
        // Check deadline
        require(
            block.timestamp <= deadline,
            "LibSignatureVerify: signature expired"
        );

        // Pack the struct fields
        bytes32 structHash = keccak256(
            abi.encode(
                _ALX_SCORE_ATTEST_TYPEHASH,
                wallet,
                score,
                epochId,
                amount,
                nonce,
                deadline
            )
        );

        // Calculate the digest using EIP-712 domain with the actual contract address
        bytes32 domainSeparator = keccak256(
            abi.encode(
                keccak256(
                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
                ),
                keccak256(bytes("ALX First Listings")),
                keccak256(bytes("1")),
                block.chainid,
                verifyingContract
            )
        );

        bytes32 digest = keccak256(
            abi.encodePacked("\x19\x01", domainSeparator, structHash)
        );

        // Verify signature using SignatureChecker
        return
            SignatureChecker.isValidSignatureNow(
                trustedSigner,
                digest,
                signature
            );
    }
}
